<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/flashcardapp/DeckDetailActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/flashcardapp/DeckDetailActivity.kt" />
              <option name="originalContent" value="package com.example.flashcardapp&#10;&#10;import android.app.Activity&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.widget.Toast&#10;import androidx.activity.OnBackPressedCallback&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.widget.doOnTextChanged&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import com.example.flashcardapp.databinding.DeckDetailsBinding&#10;import com.example.flashcardapp.model.Card&#10;import com.example.flashcardapp.model.Deck&#10;import com.example.flashcardapp.ui.CardRowAdapter&#10;import com.example.flashcardapp.ui.CardRowAdapter.CardSide&#10;import io.github.jan.supabase.postgrest.from&#10;import kotlinx.coroutines.launch&#10;import kotlinx.serialization.json.JsonPrimitive&#10;import kotlinx.serialization.json.buildJsonObject&#10;&#10;class DeckDetailActivity : AppCompatActivity() {&#10;&#10;    private lateinit var binding: DeckDetailsBinding&#10;&#10;    companion object {&#10;        private const val TAG = &quot;DeckDetailActivity&quot;&#10;        const val EXTRA_DECK_ID = &quot;extra_deck_id&quot;&#10;    }&#10;&#10;    private var editMode: Boolean = false&#10;    private var currentDeck: Deck? = null&#10;    private lateinit var adapter: CardRowAdapter&#10;    private var deckChanged: Boolean = false // track if any field updated&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        binding = DeckDetailsBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        val deckId = intent.getIntExtra(EXTRA_DECK_ID, -1)&#10;        if (deckId == -1) {&#10;            Toast.makeText(this, &quot;Missing deck id&quot;, Toast.LENGTH_SHORT).show()&#10;            finish()&#10;            return&#10;        }&#10;&#10;        // RecyclerView setup for cards with cell click support&#10;        adapter = CardRowAdapter(emptyList()) { card, side -&gt;&#10;            if (editMode) {&#10;                when (side) {&#10;                    CardSide.FRONT -&gt; showEditCardDialog(card, isFront = true)&#10;                    CardSide.BACK -&gt; showEditCardDialog(card, isFront = false)&#10;                }&#10;            }&#10;        }&#10;        binding.rvDeckCards.layoutManager = LinearLayoutManager(this)&#10;        binding.rvDeckCards.adapter = adapter&#10;&#10;        // Add card button navigates to DeckAddingActivity in card mode (disabled in edit mode)&#10;        binding.btnAdd.setOnClickListener {&#10;            if (editMode) return@setOnClickListener&#10;            val intent = Intent(this, DeckAddingActivity::class.java)&#10;            intent.putExtra(DeckAddingActivity.EXTRA_MODE, DeckAddingActivity.MODE_CARD)&#10;            intent.putExtra(DeckAddingActivity.EXTRA_DECK_ID, deckId)&#10;            startActivity(intent)&#10;        }&#10;&#10;        // Edit button toggles edit mode&#10;        binding.btnEdit.setOnClickListener {&#10;            toggleEditMode()&#10;        }&#10;&#10;        // Delete button with confirmation (disabled in edit mode)&#10;        binding.btnDelete.setOnClickListener {&#10;            if (editMode) return@setOnClickListener&#10;            confirmAndDeleteDeck()&#10;        }&#10;&#10;        // Study button navigates to StudyActivity&#10;        binding.btnStudy.setOnClickListener {&#10;            val id = currentDeck?.id ?: intent.getIntExtra(EXTRA_DECK_ID, -1)&#10;            if (id == -1) {&#10;                Toast.makeText(this, &quot;Missing deck id&quot;, Toast.LENGTH_SHORT).show()&#10;            } else {&#10;                val i = Intent(this, StudyActivity::class.java)&#10;                i.putExtra(EXTRA_DECK_ID, id)&#10;                startActivity(i)&#10;            }&#10;        }&#10;&#10;        // Click on title/description opens edit only in edit mode&#10;        binding.tvDeckNameTop.setOnClickListener {&#10;            if (editMode) showEditTitleDialog()&#10;        }&#10;        binding.tvDeckDescription.setOnClickListener {&#10;            if (editMode) showEditDescriptionDialog()&#10;        }&#10;&#10;        // Load deck info and cards&#10;        lifecycleScope.launch {&#10;            try {&#10;                Log.d(TAG, &quot;Fetching deck info for id=$deckId&quot;)&#10;                val deckList = SupabaseProvider.client.from(&quot;Deck&quot;)&#10;                    .select { filter { eq(&quot;id&quot;, deckId) } }&#10;                    .decodeList&lt;Deck&gt;()&#10;                val deck = deckList.firstOrNull()&#10;                if (deck == null) {&#10;                    Toast.makeText(this@DeckDetailActivity, &quot;Deck not found&quot;, Toast.LENGTH_SHORT).show()&#10;                    finish()&#10;                    return@launch&#10;                }&#10;                currentDeck = deck&#10;                // Set title/description&#10;                binding.tvDeckNameTop.text = deck.name&#10;                binding.tvDeckDescription.text = deck.description ?: &quot;&quot;&#10;&#10;                Log.d(TAG, &quot;Fetching cards for deck=$deckId&quot;)&#10;                val cards = SupabaseProvider.client.from(&quot;Card&quot;)&#10;                    .select { filter { eq(&quot;deck_id&quot;, deckId) } }&#10;                    .decodeList&lt;Card&gt;()&#10;                Log.d(TAG, &quot;Fetched ${cards.size} cards&quot;)&#10;                adapter.submitList(cards)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error loading deck details&quot;, e)&#10;                Toast.makeText(this@DeckDetailActivity, &quot;Error: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            }&#10;        }&#10;&#10;        // Handle system back with dispatcher (instead of deprecated override)&#10;        onBackPressedDispatcher.addCallback(this, object : OnBackPressedCallback(true) {&#10;            override fun handleOnBackPressed() {&#10;                if (deckChanged &amp;&amp; currentDeck?.id != null) {&#10;                    val resultIntent = Intent().apply {&#10;                        putExtra(&quot;deck_updated&quot;, true)&#10;                        putExtra(&quot;deck_id&quot;, currentDeck!!.id!!)&#10;                        putExtra(&quot;deck_name&quot;, currentDeck!!.name)&#10;                        putExtra(&quot;deck_description&quot;, currentDeck!!.description ?: &quot;&quot;)&#10;                    }&#10;                    setResult(Activity.RESULT_OK, resultIntent)&#10;                } else {&#10;                    setResult(Activity.RESULT_CANCELED)&#10;                }&#10;                finish()&#10;            }&#10;        })&#10;    }&#10;&#10;    private fun toggleEditMode() {&#10;        editMode = !editMode&#10;        binding.btnAdd.isEnabled = !editMode&#10;        binding.btnDelete.isEnabled = !editMode&#10;&#10;        // Provide visual feedback on edit button (optional tint change via alpha)&#10;        binding.btnEdit.alpha = if (editMode) 1.0f else 0.5f&#10;&#10;        val msg = if (editMode) &quot;Edit mode ON: tap fields to edit&quot; else &quot;Edit mode OFF&quot;&#10;        Toast.makeText(this, msg, Toast.LENGTH_SHORT).show()&#10;    }&#10;&#10;    private fun showEditTitleDialog() {&#10;        val deck = currentDeck ?: return&#10;        val input = android.widget.EditText(this).apply {&#10;            setText(deck.name)&#10;            setSelection(text.length)&#10;        }&#10;        AlertDialog.Builder(this)&#10;            .setTitle(&quot;Edit deck title&quot;)&#10;            .setView(input)&#10;            .setPositiveButton(&quot;Save&quot;) { dialog, _ -&gt;&#10;                val newTitle = input.text.toString().trim()&#10;                if (newTitle.isNotEmpty() &amp;&amp; newTitle != deck.name) {&#10;                    saveDeckField(&quot;name&quot;, newTitle) {&#10;                        currentDeck = deck.copy(name = newTitle)&#10;                        binding.tvDeckNameTop.text = newTitle&#10;                    }&#10;                }&#10;                dialog.dismiss()&#10;            }&#10;            .setNegativeButton(&quot;Cancel&quot;) { dialog, _ -&gt; dialog.dismiss() }&#10;            .show()&#10;    }&#10;&#10;    private fun showEditDescriptionDialog() {&#10;        val deck = currentDeck ?: return&#10;        val input = android.widget.EditText(this).apply {&#10;            setText(deck.description ?: &quot;&quot;)&#10;            doOnTextChanged { _, _, _, _ -&gt; }&#10;        }&#10;        AlertDialog.Builder(this)&#10;            .setTitle(&quot;Edit description&quot;)&#10;            .setView(input)&#10;            .setPositiveButton(&quot;Save&quot;) { dialog, _ -&gt;&#10;                val newDesc = input.text.toString().trim()&#10;                saveDeckField(&quot;description&quot;, newDesc) {&#10;                    currentDeck = deck.copy(description = newDesc)&#10;                    binding.tvDeckDescription.text = newDesc&#10;                }&#10;                dialog.dismiss()&#10;            }&#10;            .setNegativeButton(&quot;Cancel&quot;) { dialog, _ -&gt; dialog.dismiss() }&#10;            .show()&#10;    }&#10;&#10;    private fun showEditCardDialog(card: Card, isFront: Boolean) {&#10;        val input = android.widget.EditText(this).apply {&#10;            setText(if (isFront) card.front else card.back)&#10;            setSelection(text.length)&#10;        }&#10;        val title = if (isFront) &quot;Edit front&quot; else &quot;Edit back&quot;&#10;        AlertDialog.Builder(this)&#10;            .setTitle(title)&#10;            .setView(input)&#10;            .setPositiveButton(&quot;Save&quot;) { dialog, _ -&gt;&#10;                val newText = input.text.toString()&#10;                saveCardField(card, isFront, newText)&#10;                dialog.dismiss()&#10;            }&#10;            .setNegativeButton(&quot;Cancel&quot;) { dialog, _ -&gt; dialog.dismiss() }&#10;            .show()&#10;    }&#10;&#10;    private fun saveDeckField(field: String, value: String, onLocalApply: () -&gt; Unit) {&#10;        val deckId = currentDeck?.id ?: return&#10;        lifecycleScope.launch {&#10;            try {&#10;                val body = buildJsonObject { put(field, JsonPrimitive(value)) }&#10;                SupabaseProvider.client.from(&quot;Deck&quot;).update(&#10;                    body&#10;                ) {&#10;                    filter { eq(&quot;id&quot;, deckId) }&#10;                }&#10;                Log.d(TAG, &quot;Updated deck $field successfully&quot;)&#10;                deckChanged = true // mark change&#10;                onLocalApply()&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Failed updating deck $field&quot;, e)&#10;                Toast.makeText(this@DeckDetailActivity, &quot;Update failed: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveCardField(card: Card, isFront: Boolean, newText: String) {&#10;        val id = card.id ?: run {&#10;            Toast.makeText(this, &quot;Card id missing&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;        val field = if (isFront) &quot;front&quot; else &quot;back&quot;&#10;        lifecycleScope.launch {&#10;            try {&#10;                val body = buildJsonObject { put(field, JsonPrimitive(newText)) }&#10;                SupabaseProvider.client.from(&quot;Card&quot;).update(&#10;                    body&#10;                ) {&#10;                    filter { eq(&quot;id&quot;, id) }&#10;                }&#10;                // Refresh list to reflect the latest content&#10;                refreshCards()&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Failed updating card ${card.id}&quot;, e)&#10;                Toast.makeText(this@DeckDetailActivity, &quot;Update failed: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun refreshCards() {&#10;        val deckId = currentDeck?.id ?: return&#10;        lifecycleScope.launch {&#10;            try {&#10;                val cards = SupabaseProvider.client.from(&quot;Card&quot;)&#10;                    .select { filter { eq(&quot;deck_id&quot;, deckId) } }&#10;                    .decodeList&lt;Card&gt;()&#10;                adapter.submitList(cards)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Failed to refresh cards&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun confirmAndDeleteDeck() {&#10;        val deckId = currentDeck?.id ?: run {&#10;            Toast.makeText(this, &quot;Deck id missing&quot;, Toast.LENGTH_SHORT).show(); return&#10;        }&#10;        AlertDialog.Builder(this)&#10;            .setTitle(&quot;Delete Deck&quot;)&#10;            .setMessage(&quot;Are you sure you want to delete this deck? All its cards will be removed.&quot;)&#10;            .setPositiveButton(&quot;Delete&quot;) { dialog, _ -&gt;&#10;                dialog.dismiss()&#10;                lifecycleScope.launch {&#10;                    try {&#10;                        Log.d(TAG, &quot;Deleting deck id=$deckId&quot;)&#10;                        SupabaseProvider.client.from(&quot;Deck&quot;).delete {&#10;                            filter { eq(&quot;id&quot;, deckId) }&#10;                        }&#10;                        Toast.makeText(this@DeckDetailActivity, &quot;Deck deleted&quot;, Toast.LENGTH_SHORT).show()&#10;                        // Return deletion result&#10;                        val resultIntent = Intent().apply {&#10;                            putExtra(&quot;deck_deleted&quot;, true)&#10;                            putExtra(&quot;deck_id&quot;, deckId)&#10;                        }&#10;                        setResult(Activity.RESULT_OK, resultIntent)&#10;                        finish()&#10;                    } catch (e: Exception) {&#10;                        Log.e(TAG, &quot;Failed deleting deck&quot;, e)&#10;                        Toast.makeText(this@DeckDetailActivity, &quot;Delete failed: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;                    }&#10;                }&#10;            }&#10;            .setNegativeButton(&quot;Cancel&quot;) { dialog, _ -&gt; dialog.dismiss() }&#10;            .show()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.flashcardapp&#10;&#10;import android.app.Activity&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.widget.Toast&#10;import androidx.activity.OnBackPressedCallback&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.widget.doOnTextChanged&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import com.example.flashcardapp.databinding.DeckDetailsBinding&#10;import com.example.flashcardapp.model.Card&#10;import com.example.flashcardapp.model.Deck&#10;import com.example.flashcardapp.ui.CardRowAdapter&#10;import com.example.flashcardapp.ui.CardRowAdapter.CardSide&#10;import io.github.jan.supabase.postgrest.from&#10;import kotlinx.coroutines.launch&#10;import kotlinx.serialization.json.JsonPrimitive&#10;import kotlinx.serialization.json.buildJsonObject&#10;&#10;class DeckDetailActivity : AppCompatActivity() {&#10;&#10;    private lateinit var binding: DeckDetailsBinding&#10;&#10;    companion object {&#10;        private const val TAG = &quot;DeckDetailActivity&quot;&#10;        const val EXTRA_DECK_ID = &quot;extra_deck_id&quot;&#10;    }&#10;&#10;    private var editMode: Boolean = false&#10;    private var currentDeck: Deck? = null&#10;    private lateinit var adapter: CardRowAdapter&#10;    private var deckChanged: Boolean = false // track if any field updated&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        binding = DeckDetailsBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        val deckId = intent.getIntExtra(EXTRA_DECK_ID, -1)&#10;        if (deckId == -1) {&#10;            Toast.makeText(this, &quot;Missing deck id&quot;, Toast.LENGTH_SHORT).show()&#10;            finish()&#10;            return&#10;        }&#10;&#10;        // RecyclerView setup for cards with cell click support&#10;        adapter = CardRowAdapter(emptyList()) { card, side -&gt;&#10;            if (editMode) {&#10;                when (side) {&#10;                    CardSide.FRONT -&gt; showEditCardDialog(card, isFront = true)&#10;                    CardSide.BACK -&gt; showEditCardDialog(card, isFront = false)&#10;                }&#10;            }&#10;        }&#10;        binding.rvDeckCards.layoutManager = LinearLayoutManager(this)&#10;        binding.rvDeckCards.adapter = adapter&#10;&#10;        // Add card button navigates to DeckAddingActivity in card mode (disabled in edit mode)&#10;        binding.btnAdd.setOnClickListener {&#10;            if (editMode) return@setOnClickListener&#10;            val intent = Intent(this, DeckAddingActivity::class.java)&#10;            intent.putExtra(DeckAddingActivity.EXTRA_MODE, DeckAddingActivity.MODE_CARD)&#10;            intent.putExtra(DeckAddingActivity.EXTRA_DECK_ID, deckId)&#10;            startActivity(intent)&#10;        }&#10;&#10;        // Edit button toggles edit mode&#10;        binding.btnEdit.setOnClickListener {&#10;            toggleEditMode()&#10;        }&#10;&#10;        // Delete button with confirmation (disabled in edit mode)&#10;        binding.btnDelete.setOnClickListener {&#10;            if (editMode) return@setOnClickListener&#10;            confirmAndDeleteDeck()&#10;        }&#10;&#10;        // Study button navigates to StudyActivity&#10;        binding.btnStudy.setOnClickListener {&#10;            val id = currentDeck?.id ?: intent.getIntExtra(EXTRA_DECK_ID, -1)&#10;            if (id == -1) {&#10;                Toast.makeText(this, &quot;Missing deck id&quot;, Toast.LENGTH_SHORT).show()&#10;            } else {&#10;                val i = Intent(this, StudyActivity::class.java)&#10;                i.putExtra(EXTRA_DECK_ID, id)&#10;                startActivity(i)&#10;            }&#10;        }&#10;&#10;        // Click on title/description opens edit only in edit mode&#10;        binding.tvDeckNameTop.setOnClickListener {&#10;            if (editMode) showEditTitleDialog()&#10;        }&#10;        binding.tvDeckDescription.setOnClickListener {&#10;            if (editMode) showEditDescriptionDialog()&#10;        }&#10;&#10;        // Load deck info and cards&#10;        lifecycleScope.launch {&#10;            try {&#10;                Log.d(TAG, &quot;Fetching deck info for id=$deckId&quot;)&#10;                val deckList = SupabaseProvider.client.from(&quot;Deck&quot;)&#10;                    .select { filter { eq(&quot;id&quot;, deckId) } }&#10;                    .decodeList&lt;Deck&gt;()&#10;                val deck = deckList.firstOrNull()&#10;                if (deck == null) {&#10;                    Toast.makeText(this@DeckDetailActivity, &quot;Deck not found&quot;, Toast.LENGTH_SHORT).show()&#10;                    finish()&#10;                    return@launch&#10;                }&#10;                currentDeck = deck&#10;                // Set title/description&#10;                binding.tvDeckNameTop.text = deck.name&#10;                binding.tvDeckDescription.text = deck.description ?: &quot;&quot;&#10;&#10;                Log.d(TAG, &quot;Fetching cards for deck=$deckId&quot;)&#10;                val cards = SupabaseProvider.client.from(&quot;Card&quot;)&#10;                    .select { filter { eq(&quot;deck_id&quot;, deckId) } }&#10;                    .decodeList&lt;Card&gt;()&#10;                Log.d(TAG, &quot;Fetched ${cards.size} cards&quot;)&#10;                adapter.submitList(cards)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error loading deck details&quot;, e)&#10;                Toast.makeText(this@DeckDetailActivity, &quot;Error: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            }&#10;        }&#10;&#10;        // Handle system back with dispatcher (instead of deprecated override)&#10;        onBackPressedDispatcher.addCallback(this, object : OnBackPressedCallback(true) {&#10;            override fun handleOnBackPressed() {&#10;                if (deckChanged &amp;&amp; currentDeck?.id != null) {&#10;                    val resultIntent = Intent().apply {&#10;                        putExtra(&quot;deck_updated&quot;, true)&#10;                        putExtra(&quot;deck_id&quot;, currentDeck!!.id!!)&#10;                        putExtra(&quot;deck_name&quot;, currentDeck!!.name)&#10;                        putExtra(&quot;deck_description&quot;, currentDeck!!.description ?: &quot;&quot;)&#10;                    }&#10;                    setResult(Activity.RESULT_OK, resultIntent)&#10;                } else {&#10;                    setResult(Activity.RESULT_CANCELED)&#10;                }&#10;                finish()&#10;            }&#10;        })&#10;    }&#10;&#10;    private fun toggleEditMode() {&#10;        editMode = !editMode&#10;        binding.btnAdd.isEnabled = !editMode&#10;        binding.btnDelete.isEnabled = !editMode&#10;&#10;        // Provide visual feedback on edit button (optional tint change via alpha)&#10;        binding.btnEdit.alpha = if (editMode) 1.0f else 0.5f&#10;&#10;        val msg = if (editMode) &quot;Edit mode ON: tap fields to edit&quot; else &quot;Edit mode OFF&quot;&#10;        Toast.makeText(this, msg, Toast.LENGTH_SHORT).show()&#10;    }&#10;&#10;    private fun showEditTitleDialog() {&#10;        val deck = currentDeck ?: return&#10;        val input = android.widget.EditText(this).apply {&#10;            setText(deck.name)&#10;            setSelection(text.length)&#10;        }&#10;        AlertDialog.Builder(this)&#10;            .setTitle(&quot;Edit deck title&quot;)&#10;            .setView(input)&#10;            .setPositiveButton(&quot;Save&quot;) { dialog, _ -&gt;&#10;                val newTitle = input.text.toString().trim()&#10;                if (newTitle.isNotEmpty() &amp;&amp; newTitle != deck.name) {&#10;                    saveDeckField(&quot;name&quot;, newTitle) {&#10;                        currentDeck = deck.copy(name = newTitle)&#10;                        binding.tvDeckNameTop.text = newTitle&#10;                    }&#10;                }&#10;                dialog.dismiss()&#10;            }&#10;            .setNegativeButton(&quot;Cancel&quot;) { dialog, _ -&gt; dialog.dismiss() }&#10;            .show()&#10;    }&#10;&#10;    private fun showEditDescriptionDialog() {&#10;        val deck = currentDeck ?: return&#10;        val input = android.widget.EditText(this).apply {&#10;            setText(deck.description ?: &quot;&quot;)&#10;            doOnTextChanged { _, _, _, _ -&gt; }&#10;        }&#10;        AlertDialog.Builder(this)&#10;            .setTitle(&quot;Edit description&quot;)&#10;            .setView(input)&#10;            .setPositiveButton(&quot;Save&quot;) { dialog, _ -&gt;&#10;                val newDesc = input.text.toString().trim()&#10;                saveDeckField(&quot;description&quot;, newDesc) {&#10;                    currentDeck = deck.copy(description = newDesc)&#10;                    binding.tvDeckDescription.text = newDesc&#10;                }&#10;                dialog.dismiss()&#10;            }&#10;            .setNegativeButton(&quot;Cancel&quot;) { dialog, _ -&gt; dialog.dismiss() }&#10;            .show()&#10;    }&#10;&#10;    private fun showEditCardDialog(card: Card, isFront: Boolean) {&#10;        val input = android.widget.EditText(this).apply {&#10;            setText(if (isFront) card.front else card.back)&#10;            setSelection(text.length)&#10;        }&#10;        val title = if (isFront) &quot;Edit front&quot; else &quot;Edit back&quot;&#10;        AlertDialog.Builder(this)&#10;            .setTitle(title)&#10;            .setView(input)&#10;            .setPositiveButton(&quot;Save&quot;) { dialog, _ -&gt;&#10;                val newText = input.text.toString()&#10;                saveCardField(card, isFront, newText)&#10;                dialog.dismiss()&#10;            }&#10;            .setNegativeButton(&quot;Cancel&quot;) { dialog, _ -&gt; dialog.dismiss() }&#10;            .show()&#10;    }&#10;&#10;    private fun saveDeckField(field: String, value: String, onLocalApply: () -&gt; Unit) {&#10;        val deckId = currentDeck?.id ?: return&#10;        lifecycleScope.launch {&#10;            try {&#10;                val body = buildJsonObject { put(field, JsonPrimitive(value)) }&#10;                SupabaseProvider.client.from(&quot;Deck&quot;).update(&#10;                    body&#10;                ) {&#10;                    filter { eq(&quot;id&quot;, deckId) }&#10;                }&#10;                Log.d(TAG, &quot;Updated deck $field successfully&quot;)&#10;                deckChanged = true // mark change&#10;                onLocalApply()&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Failed updating deck $field&quot;, e)&#10;                Toast.makeText(this@DeckDetailActivity, &quot;Update failed: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveCardField(card: Card, isFront: Boolean, newText: String) {&#10;        val id = card.id ?: run {&#10;            Toast.makeText(this, &quot;Card id missing&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;        val field = if (isFront) &quot;front&quot; else &quot;back&quot;&#10;        lifecycleScope.launch {&#10;            try {&#10;                val body = buildJsonObject { put(field, JsonPrimitive(newText)) }&#10;                SupabaseProvider.client.from(&quot;Card&quot;).update(&#10;                    body&#10;                ) {&#10;                    filter { eq(&quot;id&quot;, id) }&#10;                }&#10;                // Refresh list to reflect the latest content&#10;                refreshCards()&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Failed updating card ${card.id}&quot;, e)&#10;                Toast.makeText(this@DeckDetailActivity, &quot;Update failed: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun refreshCards() {&#10;        val deckId = currentDeck?.id ?: return&#10;        lifecycleScope.launch {&#10;            try {&#10;                val cards = SupabaseProvider.client.from(&quot;Card&quot;)&#10;                    .select { filter { eq(&quot;deck_id&quot;, deckId) } }&#10;                    .decodeList&lt;Card&gt;()&#10;                adapter.submitList(cards)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Failed to refresh cards&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun confirmAndDeleteDeck() {&#10;        val deckId = currentDeck?.id ?: run {&#10;            Toast.makeText(this, &quot;Deck id missing&quot;, Toast.LENGTH_SHORT).show(); return&#10;        }&#10;        AlertDialog.Builder(this)&#10;            .setTitle(&quot;Delete Deck&quot;)&#10;            .setMessage(&quot;Are you sure you want to delete this deck? All its cards will be removed.&quot;)&#10;            .setPositiveButton(&quot;Delete&quot;) { dialog, _ -&gt;&#10;                dialog.dismiss()&#10;                lifecycleScope.launch {&#10;                    try {&#10;                        Log.d(TAG, &quot;Deleting deck id=$deckId&quot;)&#10;                        SupabaseProvider.client.from(&quot;Deck&quot;).delete {&#10;                            filter { eq(&quot;id&quot;, deckId) }&#10;                        }&#10;                        Toast.makeText(this@DeckDetailActivity, &quot;Deck deleted&quot;, Toast.LENGTH_SHORT).show()&#10;                        // Return deletion result&#10;                        val resultIntent = Intent().apply {&#10;                            putExtra(&quot;deck_deleted&quot;, true)&#10;                            putExtra(&quot;deck_id&quot;, deckId)&#10;                        }&#10;                        setResult(Activity.RESULT_OK, resultIntent)&#10;                        finish()&#10;                    } catch (e: Exception) {&#10;                        Log.e(TAG, &quot;Failed deleting deck&quot;, e)&#10;                        Toast.makeText(this@DeckDetailActivity, &quot;Delete failed: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;                    }&#10;                }&#10;            }&#10;            .setNegativeButton(&quot;Cancel&quot;) { dialog, _ -&gt; dialog.dismiss() }&#10;            .show()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>